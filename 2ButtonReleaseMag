#include <SPI.h>
#include <Ethernet2.h>

char programName[] = "Program: ethernetagain";
int systemState = 0;
int totalCount = 0;
char pageAdd[64];
String readString;

// change to your Arduino Ethernet network settings
byte mac[] = {0xA8, 0x61, 0x0A, 0xAE, 0x6C, 0xBA  };       
IPAddress ip(192,168,68,57);                               
IPAddress gateway(192, 168, 57, 1);                         
IPAddress subnet(255, 255, 252, 0);
EthernetServer Server(80);      //this is the port of the IP call

// change to your HMC network settings
IPAddress server(192,168,68,65);                           
char serverName[] = "192.168.68.65";
int serverPort = 14999;                                    
EthernetClient client;

//assign buttons
const int buttonPin1 = 2; 
const int buttonPin2 = 3; 
const int out1=6;  
bool button_1_state;
bool button_2_state;

void setup() {
  // startup arduino 
  Serial.begin(9600);   
  
  // connect arduino and ethernet shield 
  pinMode(4,OUTPUT);    
  digitalWrite(4,HIGH); 
  
  //set button pin mode
  pinMode(buttonPin1, INPUT);
  pinMode(buttonPin2, INPUT);
  pinMode(out1,OUTPUT);
  
  // Start ethernet
  Serial.println(programName);
  Serial.println("Starting Arduino Ethernet¦");
  Ethernet.begin(mac, ip, gateway, gateway, subnet);
  Serial.println(Ethernet.localIP());
  delay(2000);
  Serial.println("Arduino Ready");

  //listn for inbound communications to ethernet shield
  Server.begin();                                
}

void loop() 
{
  // Listen for commands from HMC
  EthernetClient client = Server.available();    
  // send a standard http response header
  client.println("HTTP/1.1 200 OK");
  client.println("Content-Type: text/html");
  client.println("Connnection: close");
  client.println();

 if (client)
  {
    while (client.connected())
    {
      if(client.available())
      {
        char c=client.read();
        //read char by char http request
        if (readString.length()<100){
          //store characters to string
          readString +=c;
          Serial.print(c);}
        if (c == '\n') {  
          delay(1);
           //stopping client
           client.stop();
           if (readString.indexOf("out1") >0){
               Serial.println("out1 Triggered");    
               // set output to high, magnet prop de-activates, unlocking the door         
               digitalWrite(out1,HIGH);   
               delay(1000);}
           if (readString.indexOf("reset") >0){
               Serial.println("out1 reset");
               // set output to low, magnet prop activates, locking the door  
               digitalWrite(out1,LOW);
               delay(1000);}
           readString="";}
      }
    }
  }
      if (systemState == 0){
      pushButton();}
}

byte getPage(IPAddress ipBuf,int thisPort, char *page){
int inChar;
char outBuf[128];
      Serial.print(F("connectingâ€¦"));
      if(client.connect(ipBuf,thisPort) == 1){
        Serial.println(F("connected"));
        sprintf(outBuf,"GET %s HTTP/1.1",page);
        client.println(outBuf);
        sprintf(outBuf,"Host: %s",serverName);
        client.println(outBuf);
        client.println(F("Connection: close\r\n"));}
      else{
        Serial.println(F("failed"));
        return 0;}

// connectLoop controls the hardware fail timeout
int connectLoop = 0;
    while(client.connected()){
        while(client.available()){
        inChar = client.read();
        Serial.write(inChar);
        // set connectLoop to zero if a packet arrives
        connectLoop = 0;}
    connectLoop++;

    // if more than 10000 milliseconds since the last packet
    if(connectLoop > 10000){
      // then close the connection from this end.
      Serial.println();
      Serial.println(F("Timeout"));
      client.stop();}
    // this is a delay for the connectLoop timing
    delay(1);}
  Serial.println();
  Serial.println(F("disconnecting."));
  // close client end
  client.stop();
  return 1;}
//Send get request to Houdini if button was pressed

void pushButton()
{
  // reset button state to false
  bool button_1_state = false;
  bool button_2_state = false;

  //read button 1, if pressed then set button state variable to true
  if(digitalRead(buttonPin1) == HIGH) {
    button_1_state = true;  }
  //read button 2, if pressed then set button state variable to true
  if (digitalRead(buttonPin2) == HIGH) {
    button_2_state = true;  }

  //read button states, if both are set to true, then set output to high, magnet prop de-activates, unlocking the door      
  if(button_1_state == true && button_2_state == true )
  {  
    digitalWrite(out1,HIGH);  
    delay(1000);  
    // send request to HMC, notifying Gamemaster that puzzle is complete and door is unlocked
    sprintf(pageAdd,"/out1"); (!getPage(server, serverPort, pageAdd));
    Serial.println("Button pressed");
    delay(1000);
    // release the prop
    systemState == 1;
  }

}

